length(tmp)
beta_idx <- lapply(tmp, "[[", "betas.w")
gamma_idx <- lapply(tmp, "[[", "gammas.w")
identical(beta_idx, gamma_idx)
tmp[[151]]
lambdas1 <- sapply(tmp, "[[", "lambda")
lambdas1
round(lambdas1, 5)
y2 <- y
X2 <- X
tmp[[1]]$extBIC
extbic <- sapply(tmp, "[[", "extBIC")
extbic
which.min(extbic)
tmp[[77]]
n <- 200
p <- 100
set.seed(1)
ts <- genER(p, 0.01, n, 0.5)
dat  = ts$X
data.negbin = matrix(qnbinom(pnorm(dat), mu = 2, size = 1.5),
ncol = ncol(dat))
data.bin = matrix(qbinom(pnorm(dat),
prob = 0.4, size = 1),
ncol = ncol(dat))
data = data.negbin
data[which(data.bin == 0)] = 0
data[which(data == Inf)] = max(data[which(data!=Inf)])+1
graph = ts$A
graph <- (graph != 0) * 1
mgraph <- mirror(graph)
# Method 1 scZINB -------
# step 0 marginal screening
gEstM <- marscr(log(data + 1/6), thres = 10)
# test
i <- 50
y <- data[, i]
X <- data[, which(gEstM[, i] != 0), drop = FALSE]
identical(X, X2)
identical(y, y2)
X <- log(X + 1/6)
# test gentp function
nlambda = 10
ntau = 3
unpenalizedx = NULL
unpenalizedz = NULL
offsetx = NULL
offsetz = NULL
if(.Platform$OS.type == "unix"){
sinkNul = "/dev/null"
} else {
sinkNul = 'NUL'
}
intOnly = FALSE
if(inherits(X, 'numeric') & all(X == 1)){
X = as.matrix(rep(1, length(y)))
intOnly = TRUE
M = 1
} else {
M = ncol(X) + 1
}
# XR = scale(XR, center = FALSE)
XR = scale(X, center = FALSE)
N = length(y)
if(intOnly == FALSE){
X = cbind(1, scale(X, center = FALSE))
}
fit <- try(zeroinfl(y~1 + offset(offsetx) | 1 + offset(offsetz),
dist="negbin", link = "logit"), silent = TRUE)
if(inherits(fit, 'try-error')){
capture.output(fit <- penZINB(y, 1, unpenalizedx = unpenalizedx,
unpenalizedz = unpenalizedz,
lambdas=0, taus=.1, maxIT=100,
maxOptimIT = 0, eps = 2e-3, theta = NULL,
warmStart = 'cond', pfactor = 1e-7,
oneTheta = TRUE, convType = 1,
start = 'jumpstart', order = FALSE),
file = sinkNul)
pi. <- binomial()$linkinv(fit[[1]]$gammas)
mu. <- negative.binomial(1)$linkinv(fit[[1]]$betas)
} else {
pi. <- binomial()$linkinv(fit$coefficient$zero)
mu. <- negative.binomial(1)$linkinv(fit$coefficient$count)
}
betaWeight = hessBeta(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
gammaWeight = hessGamma(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
# Important: Change Weights -------------
betaWeight <- sqrt(abs(betaWeight))
gammaWeight <- sqrt(abs(gammaWeight))
tmp <- max(betaWeight)
betaWeight <- betaWeight / tmp
gammaWeight <- gammaWeight / tmp
if(intOnly){
betaWeight2 <- betaWeight
gammaWeight2 <- gammaWeight
}else{
betaWeight2 <- betaWeight[-1]
gammaWeight2 <- gammaWeight[-1]
}
w <- pi.*(1-pi.)
r = (y - pi.)/w
# l1.g <- abs( crossprod(XR,w*r) )
l1.g <- 2 * abs( crossprod(XR,w*r) / gammaWeight2 )
w <- (mu./(1 + mu./1))
r = (y-mu.)/mu.
# l1.b <- abs(crossprod(XR,w*r) )
l1.b <- 2 * abs(crossprod(XR,w*r) / betaWeight2 )
l1.max = max(l1.g, l1.b)
nlambda <- 30
ntau <- 0.1
Thresholds <- c(exp(seq(log(l1.max), log(0.01*l1.max), len=nlambda)))
maxTau = min(l1.max/N, 0.1)
tauset = c(exp(seq(log(1e-6),log(maxTau),len=ntau)))
lambda_max <- maxTau * l1.max
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
while(length(tmp[[1]]$betas.w) > 1 | length(tmp[[1]]$gammas.w) > 1){
lambda_max <- lambda_max + 2
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
}
l1.max <- lambda_max / maxTau
Thresholds <- c(exp(seq(log(l1.max),log(pfactor*l1.max),len=nlambda)))
taus = rep(tauset, each = nlambda)
lambdas = taus*Thresholds
library(doParallel)
library(penalized) # for penalized
library(MASS) # for negative.binomal() and glm.nb
library(pscl) # for zeroinfl function
library(graph)
library(mvtnorm)
library(Rcpp)
setwd("~/Documents/Rcodes/scZINB/R")
sourceCpp("../src/utility.cpp")
files <- list.files(pattern="*.R")
files <- files[-which(files == "RcppExports.R")]
sapply(files, source, .GlobalEnv)
# Generate data -------
n <- 200
p <- 100
set.seed(1)
ts <- genER(p, 0.01, n, 0.5)
dat  = ts$X
data.negbin = matrix(qnbinom(pnorm(dat), mu = 2, size = 1.5),
ncol = ncol(dat))
data.bin = matrix(qbinom(pnorm(dat),
prob = 0.4, size = 1),
ncol = ncol(dat))
data = data.negbin
data[which(data.bin == 0)] = 0
data[which(data == Inf)] = max(data[which(data!=Inf)])+1
graph = ts$A
graph <- (graph != 0) * 1
mgraph <- mirror(graph)
# Method 1 scZINB -------
# step 0 marginal screening
gEstM <- marscr(log(data + 1/6), thres = 10)
# test
i <- 50
y <- data[, i]
X <- data[, which(gEstM[, i] != 0), drop = FALSE]
X <- log(X + 1/6)
# test gentp function
nlambda = 10
ntau = 3
unpenalizedx = NULL
unpenalizedz = NULL
offsetx = NULL
offsetz = NULL
if(.Platform$OS.type == "unix"){
sinkNul = "/dev/null"
} else {
sinkNul = 'NUL'
}
intOnly = FALSE
if(inherits(X, 'numeric') & all(X == 1)){
X = as.matrix(rep(1, length(y)))
intOnly = TRUE
M = 1
} else {
M = ncol(X) + 1
}
# XR = scale(XR, center = FALSE)
XR = scale(X, center = FALSE)
N = length(y)
if(intOnly == FALSE){
X = cbind(1, scale(X, center = FALSE))
}
fit <- try(zeroinfl(y~1 + offset(offsetx) | 1 + offset(offsetz),
dist="negbin", link = "logit"), silent = TRUE)
if(inherits(fit, 'try-error')){
capture.output(fit <- penZINB(y, 1, unpenalizedx = unpenalizedx,
unpenalizedz = unpenalizedz,
lambdas=0, taus=.1, maxIT=100,
maxOptimIT = 0, eps = 2e-3, theta = NULL,
warmStart = 'cond', pfactor = 1e-7,
oneTheta = TRUE, convType = 1,
start = 'jumpstart', order = FALSE),
file = sinkNul)
pi. <- binomial()$linkinv(fit[[1]]$gammas)
mu. <- negative.binomial(1)$linkinv(fit[[1]]$betas)
} else {
pi. <- binomial()$linkinv(fit$coefficient$zero)
mu. <- negative.binomial(1)$linkinv(fit$coefficient$count)
}
betaWeight = hessBeta(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
gammaWeight = hessGamma(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
# Important: Change Weights -------------
betaWeight <- sqrt(abs(betaWeight))
gammaWeight <- sqrt(abs(gammaWeight))
tmp <- max(betaWeight)
betaWeight <- betaWeight / tmp
gammaWeight <- gammaWeight / tmp
if(intOnly){
betaWeight2 <- betaWeight
gammaWeight2 <- gammaWeight
}else{
betaWeight2 <- betaWeight[-1]
gammaWeight2 <- gammaWeight[-1]
}
w <- pi.*(1-pi.)
r = (y - pi.)/w
# l1.g <- abs( crossprod(XR,w*r) )
l1.g <- 2 * abs( crossprod(XR,w*r) / gammaWeight2 )
w <- (mu./(1 + mu./1))
r = (y-mu.)/mu.
# l1.b <- abs(crossprod(XR,w*r) )
l1.b <- 2 * abs(crossprod(XR,w*r) / betaWeight2 )
l1.max = max(l1.g, l1.b)
nlambda <- 30
ntau <- 0.1
Thresholds <- c(exp(seq(log(l1.max), log(0.01*l1.max), len=nlambda)))
maxTau = min(l1.max/N, 0.1)
tauset = c(exp(seq(log(1e-6),log(maxTau),len=ntau)))
lambda_max <- maxTau * l1.max
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
while(length(tmp[[1]]$betas.w) > 1 | length(tmp[[1]]$gammas.w) > 1){
lambda_max <- lambda_max + 2
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
}
l1.max <- lambda_max / maxTau
Thresholds <- c(exp(seq(log(l1.max),log(pfactor*l1.max),len=nlambda)))
taus = rep(tauset, each = nlambda)
lambdas = taus*Thresholds
Thresholds <- c(exp(seq(log(l1.max),log(0.01*l1.max),len=nlambda)))
taus = rep(tauset, each = nlambda)
lambdas = taus*Thresholds
max(lambdas)
taus
nlambda <- 30
ntau <- 5
Thresholds <- c(exp(seq(log(l1.max), log(0.01*l1.max), len=nlambda)))
maxTau = min(l1.max/N, 0.1)
tauset = c(exp(seq(log(1e-6),log(maxTau),len=ntau)))
lambda_max <- maxTau * l1.max
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
while(length(tmp[[1]]$betas.w) > 1 | length(tmp[[1]]$gammas.w) > 1){
lambda_max <- lambda_max + 2
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
}
l1.max <- lambda_max / maxTau
Thresholds <- c(exp(seq(log(l1.max),log(0.01*l1.max),len=nlambda)))
taus = rep(tauset, each = nlambda)
lambdas = taus*Thresholds
max(lambdas)
library(doParallel)
library(penalized) # for penalized
library(MASS) # for negative.binomal() and glm.nb
library(pscl) # for zeroinfl function
library(graph)
library(mvtnorm)
library(Rcpp)
setwd("~/Documents/Rcodes/scZINB/R")
sourceCpp("../src/utility.cpp")
files <- list.files(pattern="*.R")
files <- files[-which(files == "RcppExports.R")]
sapply(files, source, .GlobalEnv)
# Generate data -------
n <- 200
p <- 100
set.seed(1)
ts <- genER(p, 0.01, n, 0.5)
dat  = ts$X
data.negbin = matrix(qnbinom(pnorm(dat), mu = 2, size = 1.5),
ncol = ncol(dat))
data.bin = matrix(qbinom(pnorm(dat),
prob = 0.4, size = 1),
ncol = ncol(dat))
data = data.negbin
data[which(data.bin == 0)] = 0
data[which(data == Inf)] = max(data[which(data!=Inf)])+1
graph = ts$A
graph <- (graph != 0) * 1
mgraph <- mirror(graph)
# Method 1 scZINB -------
# step 0 marginal screening
gEstM <- marscr(log(data + 1/6), thres = 10)
# test
i <- 50
y <- data[, i]
X <- data[, which(gEstM[, i] != 0), drop = FALSE]
X <- log(X + 1/6)
# test gentp function
nlambda = 10
ntau = 3
unpenalizedx = NULL
unpenalizedz = NULL
offsetx = NULL
offsetz = NULL
if(.Platform$OS.type == "unix"){
sinkNul = "/dev/null"
} else {
sinkNul = 'NUL'
}
intOnly = FALSE
if(inherits(X, 'numeric') & all(X == 1)){
X = as.matrix(rep(1, length(y)))
intOnly = TRUE
M = 1
} else {
M = ncol(X) + 1
}
# XR = scale(XR, center = FALSE)
XR = scale(X, center = FALSE)
N = length(y)
if(intOnly == FALSE){
X = cbind(1, scale(X, center = FALSE))
}
fit <- try(zeroinfl(y~1 + offset(offsetx) | 1 + offset(offsetz),
dist="negbin", link = "logit"), silent = TRUE)
if(inherits(fit, 'try-error')){
capture.output(fit <- penZINB(y, 1, unpenalizedx = unpenalizedx,
unpenalizedz = unpenalizedz,
lambdas=0, taus=.1, maxIT=100,
maxOptimIT = 0, eps = 2e-3, theta = NULL,
warmStart = 'cond', pfactor = 1e-7,
oneTheta = TRUE, convType = 1,
start = 'jumpstart', order = FALSE),
file = sinkNul)
pi. <- binomial()$linkinv(fit[[1]]$gammas)
mu. <- negative.binomial(1)$linkinv(fit[[1]]$betas)
} else {
pi. <- binomial()$linkinv(fit$coefficient$zero)
mu. <- negative.binomial(1)$linkinv(fit$coefficient$count)
}
betaWeight = hessBeta(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
gammaWeight = hessGamma(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
# Important: Change Weights -------------
betaWeight <- sqrt(abs(betaWeight))
gammaWeight <- sqrt(abs(gammaWeight))
tmp <- max(betaWeight)
betaWeight <- betaWeight / tmp
gammaWeight <- gammaWeight / tmp
if(intOnly){
betaWeight2 <- betaWeight
gammaWeight2 <- gammaWeight
}else{
betaWeight2 <- betaWeight[-1]
gammaWeight2 <- gammaWeight[-1]
}
w <- pi.*(1-pi.)
r = (y - pi.)/w
# l1.g <- abs( crossprod(XR,w*r) )
l1.g <- 2 * abs( crossprod(XR,w*r) / gammaWeight2 )
w <- (mu./(1 + mu./1))
r = (y-mu.)/mu.
# l1.b <- abs(crossprod(XR,w*r) )
l1.b <- 2 * abs(crossprod(XR,w*r) / betaWeight2 )
l1.max = max(l1.g, l1.b)
nlambda <- 30
ntau <- 5
Thresholds <- c(exp(seq(log(l1.max), log(0.01*l1.max), len=nlambda)))
maxTau = min(l1.max/N, 0.1)
tauset = c(exp(seq(log(1e-6),log(maxTau),len=ntau)))
lambda_max <- maxTau * l1.max
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
while(length(tmp[[1]]$betas.w) > 1 | length(tmp[[1]]$gammas.w) > 1){
lambda_max <- lambda_max + 2
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
}
l1.max <- lambda_max / maxTau
Thresholds <- c(exp(seq(log(l1.max),log(0.01*l1.max),len=nlambda)))
taus = rep(tauset, each = nlambda)
lambdas = taus*Thresholds
max(lambdas)
lambdas
lambdas[151]
lambdas[150]
if(is.na(any(lambdas/taus == 0) == FALSE)){
lambdas = lambdas[!is.na(lambdas) & !is.na(taus)]
taus = taus[!is.na(lambdas) & !is.na(taus)]
}
if(any(lambdas/taus == 0) == FALSE){
if(!is.null(lambdas)){
if(length(lambdas > 1)){
lambdas = c(lambdas, 0)
}
}
if(!is.null(taus)){
if(length(taus) > 1){
taus = c(taus, 0.1)
}
}
}
# sort tuning parameters from smallest to largest for warm start
tp.ratio = lambdas/taus
tp.idx = sort.int(tp.ratio, index.return = TRUE)$ix
lambdas = lambdas[tp.idx]
taus = taus[tp.idx]
lambdas
taus
library(scZINB)
library(doParallel)
library(penalized) # for penalized
library(MASS) # for negative.binomal() and glm.nb
library(pscl) # for zeroinfl function
library(graph)
library(mvtnorm)
library(scZINB)
# library(devtools)
# install_github("yliu433/scZINB")
# library(scZINB)
# Generate data -------
n <- 200
p <- 100
set.seed(1)
ts <- genER(p, 0.01, n, 0.5)
dat  = ts$X
data.negbin = matrix(qnbinom(pnorm(dat), mu = 2, size = 1.5),
ncol = ncol(dat))
data.bin = matrix(qbinom(pnorm(dat),
prob = 0.4, size = 1),
ncol = ncol(dat))
data = data.negbin
data[which(data.bin == 0)] = 0
data[which(data == Inf)] = max(data[which(data!=Inf)])+1
graph = ts$A
graph <- (graph != 0) * 1
mgraph <- mirror(graph)
# Method 1 scZINB -------
# step 0 marginal screening
gEstM <- marscr(log(data + 1/6), thres = 10)
# test
i <- 50
y <- data[, i]
X <- data[, which(gEstM[, i] != 0), drop = FALSE]
tmp <- penZINB(y, log(X + 1/6) )
length(tmp)
beta_idx <- lapply(tmp, "[[", "betas.w")
gamma_idx <- lapply(tmp, "[[", "gammas.w")
identical(beta_idx, gamma_idx)
lambdas1 <- sapply(tmp, "[[", "lambda")
taus1 <- sapply(tmp, "[[", "tau")
rm(list = ls())
ls()
library(doParallel)
library(penalized) # for penalized
library(MASS) # for negative.binomal() and glm.nb
library(pscl) # for zeroinfl function
library(graph)
library(mvtnorm)
library(scZINB)
# library(devtools)
# install_github("yliu433/scZINB")
# library(scZINB)
# Generate data -------
n <- 200
p <- 100
set.seed(1)
ts <- genER(p, 0.01, n, 0.5)
dat  = ts$X
data.negbin = matrix(qnbinom(pnorm(dat), mu = 2, size = 1.5),
ncol = ncol(dat))
data.bin = matrix(qbinom(pnorm(dat),
prob = 0.4, size = 1),
ncol = ncol(dat))
data = data.negbin
data[which(data.bin == 0)] = 0
data[which(data == Inf)] = max(data[which(data!=Inf)])+1
graph = ts$A
graph <- (graph != 0) * 1
mgraph <- mirror(graph)
# Method 1 scZINB -------
# step 0 marginal screening
gEstM <- marscr(log(data + 1/6), thres = 10)
# test
i <- 50
y <- data[, i]
X <- data[, which(gEstM[, i] != 0), drop = FALSE]
tmp <- penZINB(y, log(X + 1/6) )
length(tmp)
beta_idx <- lapply(tmp, "[[", "betas.w")
gamma_idx <- lapply(tmp, "[[", "gammas.w")
identical(beta_idx, gamma_idx)
lambdas1 <- sapply(tmp, "[[", "lambda")
taus1 <- sapply(tmp, "[[", "tau")
max(lambdas1)
unique(taus1)
round(unique(taus1), 7)
round(unique(taus1), 10)
taus1[1] == taus1[6]
taus1[1]
taus1[6]
c(exp(seq(log(1e-6),log(maxTau),len=5)))
c(exp(seq(log(1e-6),log(0.1),len=5)))
mgh1 <- nsZINB(data, filter = gEstM, unpenalizedx = unpen,
unpenalizedz = unpen)
compareGraphs(mgh1, mgraph)
# step 1 neighborhood selection
mgh1 <- nsZINB(data, filter = gEstM, unpenalizedx = NULL,
unpenalizedz = NULL)
compareGraphs(mgh1, mgraph)
sum(mgh1)
sum(mgraph)
