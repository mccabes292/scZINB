tmp <- max(betaWeight)
betaWeight <- betaWeight / tmp
gammaWeight <- gammaWeight / tmp
# remove the weight of the intercept in order to generate the grid
if(intOnly){
betaWeight2 <- betaWeight
gammaWeight2 <- gammaWeight
}else{
betaWeight2 <- betaWeight
gammaWeight2 <- gammaWeight
}
betaWeight2
gammaWeight2
setwd("~/Documents/Rcodes/scZINB/R")
sourceCpp("../src/utility.cpp")
files <- list.files(pattern="*.R")
files <- files[-which(files == "RcppExports.R")]
sapply(files, source, .GlobalEnv)
tmp1 <- penZINB(y, XR )
lambdas1 <- sapply(tmp1, "[[", "lambda")
taus1 <- sapply(tmp1, "[[", "tau")
max(lambdas1)
View(penZINB)
setwd("~/Documents/Rcodes/scZINB/R")
sourceCpp("../src/utility.cpp")
files <- list.files(pattern="*.R")
files <- files[-which(files == "RcppExports.R")]
sapply(files, source, .GlobalEnv)
tmp1 <- penZINB(y, XR )
lambdas1 <- sapply(tmp1, "[[", "lambda")
taus1 <- sapply(tmp1, "[[", "tau")
max(lambdas1)
View(hessBeta)
head(XR)
i <- 50
y <- data[, i]
X <- data[, which(gEstM[, i] != 0), drop = FALSE]
X <- log(X + 1/6)
# test gentp function
nlambda = 30
ntau = 5
unpenalizedx = NULL
unpenalizedz = NULL
offsetx = NULL
offsetz = NULL
if(.Platform$OS.type == "unix"){
sinkNul = "/dev/null"
} else {
sinkNul = 'NUL'
}
intOnly = FALSE
if(inherits(X, 'numeric') & all(X == 1)){
X = as.matrix(rep(1, length(y)))
intOnly = TRUE
M = 1
} else {
M = ncol(X) + 1
}
# XR = scale(XR, center = FALSE)
XR = scale(X, center = FALSE)
N = length(y)
if(intOnly == FALSE){
X = cbind(1, scale(X, center = FALSE))
}
fit <- try(zeroinfl(y~1 + offset(offsetx) | 1 + offset(offsetz),
dist="negbin", link = "logit"), silent = TRUE)
if(inherits(fit, 'try-error')){
capture.output(fit <- penZINB(y, 1, unpenalizedx = unpenalizedx,
unpenalizedz = unpenalizedz,
lambdas=0, taus=.1, maxIT=100,
maxOptimIT = 0, eps = 2e-3, theta = NULL,
warmStart = 'cond', pfactor = 1e-7,
oneTheta = TRUE, convType = 1,
start = 'jumpstart', order = FALSE),
file = sinkNul)
pi. <- binomial()$linkinv(fit[[1]]$gammas)
mu. <- negative.binomial(1)$linkinv(fit[[1]]$betas)
} else {
pi. <- binomial()$linkinv(fit$coefficient$zero)
mu. <- negative.binomial(1)$linkinv(fit$coefficient$count)
}
pfactor <- 0.01
betaWeight = hessBeta(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
gammaWeight = hessGamma(X, rep(0,M), rep(0, N), rep(0,M), rep(0, N), y, 1)
# Important: Change Weights -------------
betaWeight <- sqrt(abs(betaWeight))
gammaWeight <- sqrt(abs(gammaWeight))
tmp <- max(betaWeight)
betaWeight <- betaWeight / tmp
gammaWeight <- gammaWeight / tmp
if(intOnly){
betaweight <- betaWeight
gammaweight <- gammaWeight
}else{
betaweight <- betaWeight[-1]
gammaweight <- gammaWeight[-1]
}
w <- pi.*(1-pi.)
r = (y - pi.)/w
l1.g <- 2 * abs( crossprod(XR,w*r) / gammaweight )
w <- (mu./(1 + mu./1))
r = (y-mu.)/mu.
l1.b <- 2 * abs(crossprod(XR,w*r) / betaweight )
l1.max = max(l1.g, l1.b)
Thresholds <- c(exp(seq(log(l1.max),log(pfactor*l1.max),len=nlambda)))
# Thresholds <- c(seq(l1.max,pfactor*l1.max,len=nlambda))
maxTau = min(l1.max/N, 0.1)
tauset = c(exp(seq(log(1e-6),log(maxTau),len=ntau)))
lambda_max <- maxTau * l1.max
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
while(length(tmp[[1]]$betas.w) > 1 | length(tmp[[1]]$gammas.w) > 1){
lambda_max <- lambda_max + 2
tmp <- penZINB(y, XR, lambdas = lambda_max, taus = max(tauset) )
}
l1.max <- lambda_max / maxTau
Thresholds <- c(exp(seq(log(l1.max),log(pfactor*l1.max),len=nlambda)))
taus = rep(tauset, each = nlambda)
lambdas = taus*Thresholds
max(lambdas)
l1.max
X <- XR
unpenalizedx = NULL
unpenalizedz = NULL
lambdas = NULL
taus = NULL
nlambda = 30
ntau = 5
naPercent =.4
maxIT = 1000
maxIT2 = 25
track = NULL
theta.st = NULL
stepThrough = NULL
optimType = "EM"
loud = NULL
warmStart = TRUE
bicgamma = NULL
irlsConv = FALSE
weightedPen = TRUE
numericalDeriv = FALSE
pfactor = 1e-2
oneTheta = FALSE
maxOptimIT = 50
errorDirec = tempdir()
eps = 1e-5
convType = 1
start = NULL
order = FALSE
alwaysUpdateWeights = FALSE
penType = 1
# Create Intermediate Variables
##############################
intOnly = FALSE
if(inherits(X, 'numeric') & all(X == 1)){
X = as.matrix(rep(1, length(y)))
intOnly = TRUE
M = 1
} else {
M = ncol(X) + 1
}
N = length(y)
Y0 <- which(y <= 0)
Y1 <- which(y > 0)
if(.Platform$OS.type == "unix"){
sinkNul = "/dev/null"
} else {
sinkNul = 'NUL'
}
# Check inputs
##############################
if(!is.numeric(y)){
stop("y must be a numeric vector\n")
}
if(!is.matrix(X)){
stop("X must be a matrix\n")
}
if(N <= 2){
warning("sample size is too small\n")
return(NULL)
}
if(nrow(X) != N){
stop("the dimension of X and y do not match\n")
}
if(!is.null(unpenalizedx)){
if((! is.numeric(unpenalizedx)) || nrow(unpenalizedx) != N){
stop("unpenalizedx must be a numeric matrix of
the number of rows as the length as y\n")
}
useOffsetx = 1
}else{
useOffsetx = 0
unpenalizedx = NULL
}
if(!is.null(unpenalizedz)){
if((! is.numeric(unpenalizedz)) || nrow(unpenalizedz) != N){
stop("unpenalizedz must be a numeric matrix of the number of rows
as the length as y\n")
}
useOffsetz = 1
}else{
useOffsetz = 0
unpenalizedz = NULL
}
# Filter missing values
##############################
isNA = apply(X, 1, function(v){ any(is.na(v)) })
isNA = is.na(y) | isNA
if(length(which(isNA))/N > naPercent){
cat(y)
print(X)
stop("percent of missing data is too high\n")
}
w2kp  = which(!isNA)
if(length(w2kp) == 0){
warning("there is no non-missing values\n")
return(NULL)
}
yR    = y[w2kp]
XR    = X[w2kp, ,drop=FALSE]
if(useOffsetx){
unpenalizedx = unpenalizedx[w2kp, ,drop=FALSE]
}
if(useOffsetz){
unpenalizedz = unpenalizedz[w2kp, ,drop=FALSE]
}
XR = scale(XR, center = FALSE)
yN    = yR
if(order == TRUE){
corr = cor(y, X)
o = order(corr,decreasing=T)
o.back = order(o)
X = X[,o]
} else {
o.back = seq(1:ncol(X))
}
# Add intercept
if(intOnly == FALSE){
X = cbind(1, scale(X, center = FALSE))
}
# Initialize starting parameters and result
# container
if(is.null(start)){
start = list(betas = rep(0, M), gammas = rep(0, M))
if(useOffsetx){
fit_nb <- glm.nb(y~1+unpenalizedx)
b0 <- coefficients(fit_nb)
offsetx <- c(unpenalizedx %*% b0[-1])
}else{
offsetx <- rep(0, N)
}
if(useOffsetz){
fit_log <- glm((y==0)~1+unpenalizedz, family = "binomial")
g0 <- coefficients(fit_log)
offsetz <- c(unpenalizedz %*% g0[-1])
}else{
offsetz <- rep(0, N)
}
} else if(start == 'jumpstart'){
if(intOnly){
start = list()
if(useOffsetx){
fit_nb <- glm.nb(y~1+unpenalizedx)
b0 <- coefficients(fit_nb)
b <- b0[1]
offsetx <- c(unpenalizedx %*% b0[-1])
start$betas = b
}else{
fit_nb <- glm.nb(y~1)
b0 <- coefficients(fit_nb)
b <- b0[1]
offsetx <- rep(0, N)
start$betas = b
}
if(useOffsetz){
fit_log <- glm((y==0)~1+unpenalizedz, family = "binomial")
g0 <- coefficients(fit_log)
g <- g0[1]
offsetz <- c(unpenalizedz %*% g0[-1])
start$gammas = g
}else{
fit_log <- glm((y==0)~1, family = "binomial")
g0 <- coefficients(fit_log)
g <- g0[1]
offsetz <- rep(0, N)
start$gammas = g
}
} else {
start = list()
if(useOffsetx){
fit_nb2 <- penalized(y, X[, -1, drop = FALSE],
unpenalized = ~ 1 + unpenalizedx,
model="poisson", lambda1 = 1,
trace = FALSE)
b <- c(coef(fit_nb2, "unpenalized")[1], coef(fit_nb2, "penalized"))
offsetx <- c(unpenalizedx %*% coef(fit_nb2, "unpenalized")[-1])
start$betas = b
}else{
fit_nb2 <- penalized(y, X[, -1, drop = FALSE],
model="poisson", lambda1 = 1,
trace = FALSE)
b <- coef(fit_nb2, "all")
offsetx <- rep(0, N)
start$betas = b
}
if(useOffsetz){
fit_log2 <- penalized(y==0, X[, -1, drop = FALSE],
unpenalized = ~ 1 + unpenalizedz,
model="logistic", lambda1 = 1,
trace = FALSE)
g <- c(coef(fit_log2, "unpenalized")[1], coef(fit_log2, "penalized"))
offsetz <- c(unpenalizedz %*% coef(fit_log2, "unpenalized")[-1])
start$gammas = g
}else{
fit_log2 <- penalized(y==0, X[, -1, drop = FALSE],
model="logistic", lambda1 = 1,
trace = FALSE)
g <- coef(fit_log2, "all")
offsetz <- rep(0, N)
start$gammas = g
}
}
}
betas = start$betas
gammas = start$gammas
theta = theta.st
if(is.null(theta)){
linkobj.z = binomial()
linkobj.count = negative.binomial(1)
etaz = X%*%gammas + offsetz
pij = linkobj.z$linkinv(etaz)
eta = X%*%betas + offsetx
mu = linkobj.count$linkinv(eta)
fnb = dnbinom(y, mu = mu, size = 1)
############################ Calculate expected value of latent var z
zGy= (pij/(pij + fnb*(1-pij)))*(y==0)
temp = updateTheta(betas, gammas, offsetx, offsetz, lambda, tau, theta.st,
1, Y0, X, zGy, y)
theta = temp[1]
}
nconv = 0
it = 0
result = list()
if(weightedPen == TRUE){
if(numericalDeriv == FALSE){
betaWeight = hessBeta(X, rep(0,M), offsetz, rep(0,M), offsetx, y, 1)
gammaWeight = hessGamma(X, rep(0,M), offsetz, rep(0,M), offsetx, y, 1)
} else {
betaWeight = -diag(hessian(updateObsLik.beta, rep(0,M),X= X,
gammas=rep(0,M), offsetz=offsetz,
offsetx=offsetx, y =y, Y0=Y0,
theta=1, lambda=0, tau =0.1))
gammaWeight = -diag(hessian(updateObsLik.gamma, rep(0,M),X= X,
betas=rep(0,M), offsetz=offsetz,
offsetx=offsetx, y =y, Y0=Y0,
theta=1, lambda=0, tau =0.1))
}
##############################################
if(any(is.na(c(betaWeight, gammaWeight))) |
any(c(betaWeight, gammaWeight) < 0)){
# browser()
# warning(paste("Numerical problem calculating Hessian at:",
#               lambda, ",", tau,"// theta iteration:", it.theta))
betaWeight = rep(1, length(betaWeight))
gammaWeight = rep(1, length(gammaWeight))
}
} else {
betaWeight = rep(1, M)
gammaWeight = rep(1,M)
}
# Scale Weights -------------
betaWeight <- sqrt(abs(betaWeight))
gammaWeight <- sqrt(abs(gammaWeight))
tmp <- max(betaWeight)
betaWeight <- betaWeight / tmp
gammaWeight <- gammaWeight / tmp
# remove the weight of the intercept in order to generate the grid
if(intOnly){
betaWeight2 <- betaWeight
gammaWeight2 <- gammaWeight
}else{
betaWeight2 <- betaWeight[-1]
gammaWeight2 <- gammaWeight[-1]
}
betaWeight2
gammaWeight2
tps = gentp(y, XR, nlambda, ntau, unpenalizedx, unpenalizedz, offsetx,
offsetz, betaWeight2, gammaWeight2)
tps
[,1]      [,2]       [,3]       [,4]       [,5]
[1,]  0.7106296 -1.080232 -1.1095207 -1.0841685 -1.0547357
[2,]  0.4766734 -1.080232 -1.1095207 -1.0841685 -1.0547357
[3,] -1.1046239 -1.080232 -1.1095207 -1.0841685  0.9667125
[4,] -1.1046239 -1.080232  0.7137798  1.2707174 -1.0547357
[5,] -1.1046239 -1.080232  0.8837208 -1.0841685 -1.0547357
[6,] -1.1046239  1.506438 -1.1095207  0.8635281  1.0708644
[,6]       [,7]       [,8]       [,9]
[1,]  0.4475064 -1.0802933 -1.1022636 -1.0617757
[2,] -1.0370334 -1.0802933 -1.1022636  0.6830644
[3,]  0.6671471  1.3982478 -1.1022636  0.8456924
[4,]  0.6671471  0.6949772  0.4756549  0.6830644
[5,]  0.6671471 -1.0802933 -1.1022636 -1.0617757
[6,]  0.4475064 -1.0802933  0.4756549 -1.0617757
[,10]
[1,] -1.0776166
[2,]  0.6932552
[3,]  0.9876838
[4,]  0.4650190
[5,]  1.1844792
XR
head(XR)
X <- XR
X <- XR
nlambda = 30
ntau = 5
unpenalizedx = NULL
unpenalizedz = NULL
offsetx = NULL
offsetz = NULL
betaweight = betaWeight2
gammaweight = gammaWeight2
pfactor = 1e-2
penType = 1
if(.Platform$OS.type == "unix"){
sinkNul = "/dev/null"
} else {
sinkNul = 'NUL'
}
XR = scale(X, center = FALSE)
N = length(y)
# Create tuning parameter grid if not given
if(is.null(offsetx)){
offsetx = rep(0, length(y))
}
if(is.null(offsetz)){
offsetz = rep(0, length(y))
}
fit <- try(zeroinfl(y~1 + offset(offsetx) | 1 + offset(offsetz),
dist="negbin", link = "logit"), silent = TRUE)
if(inherits(fit, 'try-error')){
capture.output(fit <- penZINB(y, 1, unpenalizedx = unpenalizedx,
unpenalizedz = unpenalizedz,
lambdas=0, taus=.1, maxIT=100,
maxOptimIT = 0, eps = 2e-3, theta = NULL,
warmStart = 'cond', pfactor = 1e-7,
oneTheta = TRUE, convType = 1,
start = 'jumpstart', order = FALSE),
file = sinkNul)
pi. <- binomial()$linkinv(fit[[1]]$gammas)
mu. <- negative.binomial(1)$linkinv(fit[[1]]$betas)
} else {
pi. <- binomial()$linkinv(fit$coefficient$zero)
mu. <- negative.binomial(1)$linkinv(fit$coefficient$count)
}
w <- pi.*(1-pi.)
r = (y - pi.)/w
l1.g <- 2 * abs( crossprod(XR,w*r) / gammaweight )
w <- (mu./(1 + mu./1))
r = (y-mu.)/mu.
l1.b <- 2 * abs(crossprod(XR,w*r) / betaweight )
l1.max = max(l1.g, l1.b)
l1.max
head(XR)
gammaweight
pi.
unpenalizedx
unpenalizedz
offsetx
offsetz
X <- XR
nlambda = 30
ntau = 5
unpenalizedx = NULL
unpenalizedz = NULL
offsetx = NULL
offsetz = NULL
betaweight = betaWeight2
gammaweight = gammaWeight2
pfactor = 1e-2
penType = 1
if(.Platform$OS.type == "unix"){
sinkNul = "/dev/null"
} else {
sinkNul = 'NUL'
}
XR = scale(X, center = FALSE)
N = length(y)
# Create tuning parameter grid if not given
fit <- try(zeroinfl(y~1 + offset(offsetx) | 1 + offset(offsetz),
dist="negbin", link = "logit"), silent = TRUE)
if(inherits(fit, 'try-error')){
capture.output(fit <- penZINB(y, 1, unpenalizedx = unpenalizedx,
unpenalizedz = unpenalizedz,
lambdas=0, taus=.1, maxIT=100,
maxOptimIT = 0, eps = 2e-3, theta = NULL,
warmStart = 'cond', pfactor = 1e-7,
oneTheta = TRUE, convType = 1,
start = 'jumpstart', order = FALSE),
file = sinkNul)
pi. <- binomial()$linkinv(fit[[1]]$gammas)
mu. <- negative.binomial(1)$linkinv(fit[[1]]$betas)
} else {
pi. <- binomial()$linkinv(fit$coefficient$zero)
mu. <- negative.binomial(1)$linkinv(fit$coefficient$count)
}
w <- pi.*(1-pi.)
r = (y - pi.)/w
l1.g <- 2 * abs( crossprod(XR,w*r) / gammaweight )
w <- (mu./(1 + mu./1))
r = (y-mu.)/mu.
l1.b <- 2 * abs(crossprod(XR,w*r) / betaweight )
l1.max = max(l1.g, l1.b)
l1.max
